<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Elbow Angle Analysis</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #f2f2f2;
      text-align: center;
      color: #333;
    }
    header {
      background-color: #003366;
      color: #fff;
      padding: 20px;
      font-size: 36px;
      font-weight: bold;
    }
    #controls {
      margin: 20px;
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
    }
    .upload-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .upload-container label {
      padding: 10px 20px;
      background-color: #003366;
      color: #fff;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin-bottom: 5px;
    }
    .upload-container input {
      display: none;
    }
    #canvasContainer {
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
    }
    canvas {
      background-color: #fff;
      border: 1px solid #ccc;
      max-width: 45%;
      height: auto;
    }
    #report {
      margin: 20px auto;
      padding: 15px;
      background: #fff;
      border: 1px solid #ccc;
      max-width: 600px;
      text-align: left;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <header>Elbow Angle Analysis</header>
  <div id="controls">
    <div class="upload-container">
      <label for="extensionInput">Upload Extension Image</label>
      <input type="file" id="extensionInput" accept="image/*">
    </div>
    <div class="upload-container">
      <label for="flexionInput">Upload Flexion Image</label>
      <input type="file" id="flexionInput" accept="image/*">
    </div>
  </div>
  <div id="canvasContainer">
    <canvas id="canvas_extension"></canvas>
    <canvas id="canvas_flexion"></canvas>
  </div>
  <div id="report"></div>
  
  <!-- Load Mediapipe Pose -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script>
    // Maximum width for scaling images
    const maxWidth = 600;
    
    // We'll use left-side landmarks (indices 11, 13, 15) for simplicity.
    const LEFT_SHOULDER_IDX = 11;
    const LEFT_ELBOW_IDX = 13;
    const LEFT_WRIST_IDX = 15;
    
    // Variables for extension image
    let extImgWidth = 0, extImgHeight = 0, extAngle = null;
    // Variables for flexion image
    let flexImgWidth = 0, flexImgHeight = 0, flexAngle = null;
    
    // Get canvas elements and report area
    const canvasExtension = document.getElementById('canvas_extension');
    const ctxExtension = canvasExtension.getContext('2d');
    const canvasFlexion = document.getElementById('canvas_flexion');
    const ctxFlexion = canvasFlexion.getContext('2d');
    const reportDiv = document.getElementById('report');
    
    // Helper: Calculate angle between three points (in degrees)
    function calculateAngle(a, b, c) {
      const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
      let angle = Math.abs(radians * 180.0 / Math.PI);
      if (angle > 180) angle = 360 - angle;
      return angle;
    }
    
    // Helper: Convert normalized landmark to pixel coordinates
    function toPixel(landmark, width, height) {
      return { x: landmark.x * width, y: landmark.y * height };
    }
    
    // Initialize Mediapipe Pose
    const pose = new Pose({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
    });
    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });
    
    // onResults callback for processing an image.
    function onResults(results, isExtension) {
      if (!results.poseLandmarks) {
        console.log("No pose landmarks detected.");
        return;
      }
      
      // For both images, we measure using left-side landmarks.
      const landmarks = results.poseLandmarks;
      const shoulder = toPixel(landmarks[LEFT_SHOULDER_IDX], isExtension ? extImgWidth : flexImgWidth, isExtension ? extImgHeight : flexImgHeight);
      const elbow = toPixel(landmarks[LEFT_ELBOW_IDX], isExtension ? extImgWidth : flexImgWidth, isExtension ? extImgHeight : flexImgHeight);
      const wrist = toPixel(landmarks[LEFT_WRIST_IDX], isExtension ? extImgWidth : flexImgWidth, isExtension ? extImgHeight : flexImgHeight);
      
      // Draw the image and overlay the drawing
      if (isExtension) {
        ctxExtension.clearRect(0, 0, extImgWidth, extImgHeight);
        ctxExtension.drawImage(results.image, 0, 0, extImgWidth, extImgHeight);
        // Draw connectors (shoulder->elbow, elbow->wrist)
        ctxExtension.beginPath();
        ctxExtension.moveTo(shoulder.x, shoulder.y);
        ctxExtension.lineTo(elbow.x, elbow.y);
        ctxExtension.lineTo(wrist.x, wrist.y);
        ctxExtension.strokeStyle = '#ffffff';
        ctxExtension.lineWidth = 6;
        ctxExtension.stroke();
        // Draw landmarks as red circles
        [shoulder, elbow, wrist].forEach(pt => {
          ctxExtension.beginPath();
          ctxExtension.arc(pt.x, pt.y, 6, 0, 2 * Math.PI);
          ctxExtension.fillStyle = '#FF0000';
          ctxExtension.fill();
        });
        extAngle = calculateAngle(shoulder, elbow, wrist);
        ctxExtension.font = "20px Arial";
        ctxExtension.fillStyle = "white";
        ctxExtension.fillText(`Angle: ${extAngle.toFixed(0)}째`, elbow.x, elbow.y - 10);
      } else {
        ctxFlexion.clearRect(0, 0, flexImgWidth, flexImgHeight);
        ctxFlexion.drawImage(results.image, 0, 0, flexImgWidth, flexImgHeight);
        ctxFlexion.beginPath();
        ctxFlexion.moveTo(shoulder.x, shoulder.y);
        ctxFlexion.lineTo(elbow.x, elbow.y);
        ctxFlexion.lineTo(wrist.x, wrist.y);
        ctxFlexion.strokeStyle = '#ffffff';
        ctxFlexion.lineWidth = 6;
        ctxFlexion.stroke();
        [shoulder, elbow, wrist].forEach(pt => {
          ctxFlexion.beginPath();
          ctxFlexion.arc(pt.x, pt.y, 6, 0, 2 * Math.PI);
          ctxFlexion.fillStyle = '#FF0000';
          ctxFlexion.fill();
        });
        flexAngle = calculateAngle(shoulder, elbow, wrist);
        ctxFlexion.font = "20px Arial";
        ctxFlexion.fillStyle = "white";
        ctxFlexion.fillText(`Angle: ${flexAngle.toFixed(0)}째`, elbow.x, elbow.y - 10);
      }
      updateReport();
    }
    
    function updateReport() {
      let reportHTML = "";
      if (extAngle !== null) {
        reportHTML += `<h3>Extension Image</h3><p>Elbow Angle: ${extAngle.toFixed(2)}째</p>`;
      }
      if (flexAngle !== null) {
        reportHTML += `<h3>Flexion Image</h3><p>Elbow Angle: ${flexAngle.toFixed(2)}째</p>`;
      }
      reportDiv.innerHTML = reportHTML;
    }
    
    // Process extension image upload
    document.getElementById('extensionInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        if (img.width > maxWidth) {
          const scale = maxWidth / img.width;
          extImgWidth = img.width * scale;
          extImgHeight = img.height * scale;
        } else {
          extImgWidth = img.width;
          extImgHeight = img.height;
        }
        canvasExtension.width = extImgWidth;
        canvasExtension.height = extImgHeight;
        ctxExtension.drawImage(img, 0, 0, extImgWidth, extImgHeight);
        pose.send({ image: img }).then(results => onResults(results, true));
      };
      img.src = URL.createObjectURL(file);
    });
    
    // Process flexion image upload
    document.getElementById('flexionInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        if (img.width > maxWidth) {
          const scale = maxWidth / img.width;
          flexImgWidth = img.width * scale;
          flexImgHeight = img.height * scale;
        } else {
          flexImgWidth = img.width;
          flexImgHeight = img.height;
        }
        canvasFlexion.width = flexImgWidth;
        canvasFlexion.height = flexImgHeight;
        ctxFlexion.drawImage(img, 0, 0, flexImgWidth, flexImgHeight);
        pose.send({ image: img }).then(results => onResults(results, false));
      };
      img.src = URL.createObjectURL(file);
    });
  </script>
</body>
</html>
