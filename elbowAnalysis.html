<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Elbow ROM Analysis</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #f2f2f2;
      text-align: center;
      color: #333;
    }
    header {
      background-color: #003366;
      color: #fff;
      padding: 20px;
      font-size: 32px;
      font-weight: bold;
    }
    .sectionContainer {
      border: 1px solid #ccc;
      background: #fff;
      padding: 15px;
      margin: 20px auto;
      max-width: 90%;
    }
    .sectionContainer h2 {
      margin-top: 0;
      color: #003366;
    }
    .upload-container {
      margin: 10px 0;
    }
    .upload-container label {
      cursor: pointer;
      padding: 10px 20px;
      background-color: #003366;
      color: #fff;
      border-radius: 5px;
      font-size: 16px;
      display: inline-block;
    }
    .upload-container input {
      display: none;
    }
    canvas {
      border: 1px solid #ccc;
      max-width: 600px;
      width: 100%;
      height: auto;
    }
    .reportArea {
      margin-top: 10px;
      text-align: left;
      font-size: 18px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
    #note {
      margin-top: 20px;
      font-size: 16px;
      font-style: italic;
    }
  </style>
</head>
<body>
  <header>Elbow ROM Analysis</header>

  <!-- Extension Section -->
  <div class="sectionContainer" id="extensionSection">
    <h2>Extension</h2>
    <div class="upload-container">
      <label for="extInput">Upload Extension Image</label>
      <input type="file" id="extInput" accept="image/*">
    </div>
    <canvas id="extCanvas"></canvas>
    <div class="reportArea" id="extReport"></div>
  </div>

  <!-- Flexion Section -->
  <div class="sectionContainer" id="flexionSection">
    <h2>Flexion</h2>
    <div class="upload-container">
      <label for="flexInput">Upload Flexion Image</label>
      <input type="file" id="flexInput" accept="image/*">
    </div>
    <canvas id="flexCanvas"></canvas>
    <div class="reportArea" id="flexReport"></div>
  </div>

  <div id="note">
    The standard values for Active ROM movements in the elbow: 130°–150°
  </div>

  <!-- Load MediaPipe Pose and Drawing Utils -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script>
    // Maximum width for image scaling
    const maxWidth = 600;

    // For Extension, we'll use the right-side landmarks (shoulder: 12, elbow: 14, wrist: 16)
    const extShoulderIdx = 12, extElbowIdx = 14, extWristIdx = 16;
    // For Flexion, we'll use the right-side landmarks (shoulder: 12, elbow: 14, wrist: 16)
    const flexShoulderIdx = 12, flexElbowIdx = 14, flexWristIdx = 16;

    // Variables for image dimensions and measured angles
    let extImgWidth = 0, extImgHeight = 0, extAngle = null;
    let flexImgWidth = 0, flexImgHeight = 0, flexAngle = null;

    // Get canvas and report elements
    const extCanvas = document.getElementById('extCanvas');
    const extCtx = extCanvas.getContext('2d');
    const extReportDiv = document.getElementById('extReport');

    const flexCanvas = document.getElementById('flexCanvas');
    const flexCtx = flexCanvas.getContext('2d');
    const flexReportDiv = document.getElementById('flexReport');

    // Helper: Calculate angle between three points (in degrees)
    function calculateAngle(a, b, c) {
      const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
      let angle = Math.abs(radians * 180.0 / Math.PI);
      if (angle > 180) angle = 360 - angle;
      return angle;
    }

    // Helper: Convert normalized landmark to pixel coordinates
    function toPixel(landmark, width, height) {
      return { x: landmark.x * width, y: landmark.y * height };
    }

    // Create two separate MediaPipe Pose instances
    const poseExt = new Pose({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
    });
    poseExt.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });

    const poseFlex = new Pose({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
    });
    poseFlex.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });

    // onResults callback for Extension image processing
    poseExt.onResults(function(results) {
      extCtx.clearRect(0, 0, extImgWidth, extImgHeight);
      extCtx.drawImage(results.image, 0, 0, extImgWidth, extImgHeight);
      if (!results.poseLandmarks) {
        extReportDiv.innerHTML = "<p>No pose detected.</p>";
        return;
      }
      // Draw all connectors in white and all landmarks in red
      window.drawConnectors(extCtx, results.poseLandmarks, Pose.POSE_CONNECTIONS, { color: '#ffffff', lineWidth: 6 });
      window.drawLandmarks(extCtx, results.poseLandmarks, { color: '#FF0000', lineWidth: 1, radius: 4 });

      const landmarks = results.poseLandmarks;
      // Calculate extension elbow angle using right-side landmarks (12, 14, 16)
      const shoulder = toPixel(landmarks[extShoulderIdx], extImgWidth, extImgHeight);
      const elbow = toPixel(landmarks[extElbowIdx], extImgWidth, extImgHeight);
      const wrist = toPixel(landmarks[extWristIdx], extImgWidth, extImgHeight);
      extAngle = calculateAngle(shoulder, elbow, wrist);

      extCtx.font = "20px Arial";
      extCtx.fillStyle = "white";
      extCtx.fillText(`Angle: ${extAngle.toFixed(0)}°`, elbow.x, elbow.y - 10);

      extReportDiv.innerHTML = `<p>Measured Elbow Angle: ${extAngle.toFixed(2)}°</p>`;
    });

    // onResults callback for Flexion image processing
    poseFlex.onResults(function(results) {
      flexCtx.clearRect(0, 0, flexImgWidth, flexImgHeight);
      flexCtx.drawImage(results.image, 0, 0, flexImgWidth, flexImgHeight);
      if (!results.poseLandmarks) {
        flexReportDiv.innerHTML = "<p>No pose detected.</p>";
        return;
      }
      window.drawConnectors(flexCtx, results.poseLandmarks, Pose.POSE_CONNECTIONS, { color: '#ffffff', lineWidth: 6 });
      window.drawLandmarks(flexCtx, results.poseLandmarks, { color: '#FF0000', lineWidth: 1, radius: 4 });

      const landmarks = results.poseLandmarks;
      // Calculate flexion elbow angle using left-side landmarks (11, 13, 15)
      const shoulder = toPixel(landmarks[flexShoulderIdx], flexImgWidth, flexImgHeight);
      const elbow = toPixel(landmarks[flexElbowIdx], flexImgWidth, flexImgHeight);
      const wrist = toPixel(landmarks[flexWristIdx], flexImgWidth, flexImgHeight);
      flexAngle = calculateAngle(shoulder, elbow, wrist);

      flexCtx.font = "20px Arial";
      flexCtx.fillStyle = "white";
      flexCtx.fillText(`Angle: ${flexAngle.toFixed(0)}°`, elbow.x, elbow.y - 10);

      flexReportDiv.innerHTML = `<p>Measured Elbow Angle: ${flexAngle.toFixed(2)}°</p>`;
    });

    // Process Extension Image Upload
    document.getElementById("extInput").addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = async () => {
        if (img.width > maxWidth) {
          const scale = maxWidth / img.width;
          extImgWidth = img.width * scale;
          extImgHeight = img.height * scale;
        } else {
          extImgWidth = img.width;
          extImgHeight = img.height;
        }
        extCanvas.width = extImgWidth;
        extCanvas.height = extImgHeight;
        extCtx.drawImage(img, 0, 0, extImgWidth, extImgHeight);
        await poseExt.send({ image: img });
      };
      img.src = URL.createObjectURL(file);
    });

    // Process Flexion Image Upload
    document.getElementById("flexInput").addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = async () => {
        if (img.width > maxWidth) {
          const scale = maxWidth / img.width;
          flexImgWidth = img.width * scale;
          flexImgHeight = img.height * scale;
        } else {
          flexImgWidth = img.width;
          flexImgHeight = img.height;
        }
        flexCanvas.width = flexImgWidth;
        flexCanvas.height = flexImgHeight;
        flexCtx.drawImage(img, 0, 0, flexImgWidth, flexImgHeight);
        await poseFlex.send({ image: img });
      };
      img.src = URL.createObjectURL(file);
    });
  </script>
</body>
</html>





